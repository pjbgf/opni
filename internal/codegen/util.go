package codegen

import (
	"io"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/cortexproject/cortex/pkg/compactor"
	"github.com/cortexproject/cortex/pkg/util/flagext"
	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/builder"
	"github.com/kralicky/protols/pkg/format"
	amcfg "github.com/prometheus/alertmanager/config"
	commoncfg "github.com/prometheus/common/config"
	"github.com/rancher/opni/internal/codegen/cli"
	"github.com/rancher/opni/internal/codegen/descriptors"
	"github.com/samber/lo"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

// from cortex doc-generator
func parseDocTag(f reflect.StructField) map[string]string {
	cfg := map[string]string{}
	tag := f.Tag.Get("doc")

	if tag == "" {
		return cfg
	}

	for _, entry := range strings.Split(tag, "|") {
		parts := strings.SplitN(entry, "=", 2)

		switch len(parts) {
		case 1:
			cfg[parts[0]] = ""
		case 2:
			cfg[parts[0]] = parts[1]
		}
	}

	return cfg
}

func editFlagOptions(rf reflect.StructField) func(*cli.FlagOptions) {
	docInfo := parseDocTag(rf)
	if _, ok := docInfo["nocli"]; ok {
		return func(fo *cli.FlagOptions) {
			fo.Skip = true
		}
	} else if rf.Name == "TenantLimits" {
		return func(fo *cli.FlagOptions) {
			fo.Skip = true
		}
	} else if rf.Type == reflect.TypeOf(flagext.Secret{}) || isSpecialCaseSecretFieldName(rf.Name) {
		return func(fo *cli.FlagOptions) {
			fo.Secret = true
		}
	}
	return nil
}

func isSpecialCaseSecretFieldName(name string) bool {
	// a couple fields don't have the flagext.Secret type, so we need to
	// check for them specifically
	return name == "MSIResource" || // AzureConfig
		name == "KMSEncryptionContext" // S3SSEConfig
}

func editFieldComment(rf reflect.StructField, in *string) {
	docInfo := parseDocTag(rf)
	if doc, ok := docInfo["description"]; ok {
		*in = doc
	}
}

var cortexTypesToSkip = map[reflect.Type]bool{
	reflect.TypeOf(compactor.RingConfig{}): true,
}

var customFieldTypes = map[reflect.Type]func() *builder.FieldType{
	reflect.TypeOf(flagext.Secret{}): func() *builder.FieldType {
		return builder.FieldTypeString()
	},
	reflect.TypeOf(amcfg.Secret("")): func() *builder.FieldType {
		return builder.FieldTypeString()
	},
	reflect.TypeOf(commoncfg.Secret("")): func() *builder.FieldType {
		return builder.FieldTypeString()
	},
}

func generate[T any](destFilename string, skipFunc ...func(rf reflect.StructField) bool) error {
	messages := descriptors.BuildMessage[T](descriptors.BuilderOptions{
		FieldNameFromTags:       []string{"json", "yaml"},
		EditFlagOptions:         editFlagOptions,
		EditFieldComment:        editFieldComment,
		AllScalarFieldsOptional: true,
		SkipFieldFunc: func(rf reflect.StructField) bool {
			if cortexTypesToSkip[rf.Type] {
				return true
			}
			if strings.HasPrefix(rf.Name, "Sharding") {
				return true
			}
			if strings.HasSuffix(rf.Name, "Dir") || strings.HasSuffix(rf.Name, "Directory") {
				return true
			}
			if _, ok := parseDocTag(rf)["hidden"]; ok {
				return true
			}
			if len(skipFunc) > 0 {
				return skipFunc[0](rf)
			}
			return false
		},
		CustomFieldTypes: customFieldTypes,
	})
	cliImport, _ := desc.WrapFile(cli.File_github_com_rancher_opni_internal_codegen_cli_cli_proto)
	f := builder.NewFile(destFilename).
		SetProto3(true).
		SetPackageName(filepath.Base(filepath.Dir(destFilename))).
		SetOptions(&descriptorpb.FileOptions{
			GoPackage: lo.ToPtr(filepath.Dir(destFilename)),
		}).
		SetSyntaxComments(builder.Comments{
			LeadingComment: "Code generated by internal/codegen. DO NOT EDIT.",
		}).
		AddImportedDependency(cliImport)
	proto.SetExtension(f.Options, cli.E_Generator, &cli.GeneratorOptions{
		Generate:         true,
		GenerateDeepcopy: true,
	})
	for _, m := range messages {
		f.AddMessage(m)
	}
	fd, err := f.Build()
	if err != nil {
		return err
	}
	var t T
	tType := reflect.TypeOf(t)
	mainMsgDesc := fd.FindMessage(filepath.Base(filepath.Dir(destFilename)) + "." + tType.Name())
	if mainMsgDesc == nil {
		panic("bug: main message not found")
	}
	customFieldTypes[tType] = func() *builder.FieldType {
		return builder.FieldTypeImportedMessage(mainMsgDesc)
	}
	p := format.NewDefaultPrinter()
	rootDir := strings.TrimPrefix(filepath.Dir(destFilename), "github.com/rancher/opni/")
	return p.PrintProtoFiles([]*desc.FileDescriptor{fd}, func(name string) (io.WriteCloser, error) {
		fullPath := filepath.Join(rootDir, filepath.Base(name))
		dir := filepath.Dir(fullPath)
		if err := os.MkdirAll(dir, os.ModePerm); err != nil {
			return nil, err
		}
		return os.OpenFile(fullPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	})
}
